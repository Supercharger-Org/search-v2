// API Configuration
const APIConfig = {
    baseURLs: {
        production: {
            patents: 'https://production-patent-api.com',
            tto: 'https://production-tto-api.com'
        },
        staging: {
            patents: 'https://staging-patent-api.com',
            tto: 'https://staging-tto-api.com'
        }
    },

    endpoints: {
        patents: {
            search: '/api/patent/search'
        },
        tto: {
            search: '/api/tto/search'
        }
    },

    getEnvironment() {
        return window.location.href.includes('.webflow.io') ? 'staging' : 'production';
    },

    getBaseURL(library) {
        const env = this.getEnvironment();
        return this.baseURLs[env][library];
    },

    getFullURL(library, endpoint) {
        if (!library || !endpoint) return null;
        const baseURL = this.getBaseURL(library);
        const endpointPath = this.endpoints[library][endpoint];
        return `${baseURL}${endpointPath}`;
    }
};

const StepConfig = {
    library: {
        options: {
            patents: {
                visibility: {
                    '#patentSpecificFields': true,
                    '#ttoSpecificFields': false
                },
                inactiveMethods: [],
                text: {
                    '[data-content="search-title"]': 'Patent Search',
                    '[data-content="search-description"]': 'Search through patent databases'
                }
            },
            tto: {
                visibility: {
                    '#patentSpecificFields': false,
                    '#ttoSpecificFields': true
                },
                inactiveMethods: ['patent'],
                text: {
                    '[data-content="search-title"]': 'TTO Search',
                    '[data-content="search-description"]': 'Search through TTO database'
                }
            }
        }
    },
    method: {
        options: {
            basic: {
                visibility: {
                    '#advancedOptions': false,
                    '#basicOptions': true,
                    '#patentOptions': false
                },
                inactiveLibraries: [],
                text: {
                    '[data-content="method-title"]': 'Basic Search'
                }
            },
            advanced: {
                visibility: {
                    '#advancedOptions': true,
                    '#basicOptions': false,
                    '#patentOptions': false
                },
                inactiveLibraries: [],
                text: {
                    '[data-content="method-title"]': 'Advanced Search'
                }
            },
            patent: {
                visibility: {
                    '#advancedOptions': true,
                    '#basicOptions': false,
                    '#patentOptions': true
                },
                inactiveLibraries: ['tto'],
                text: {
                    '[data-content="method-title"]': 'Patent Search'
                }
            }
        }
    }
};

class SessionManager {
    constructor(stepManager) {
        this.stepManager = stepManager;
        this.sessionParam = 'session';
    }

    init() {
        // Check for existing session on load
        const existingSession = this.getSessionFromURL();
        
        if (existingSession) {
            // Session exists, prepare for data restoration
            this.handleExistingSession(existingSession);
        } else {
            // No session, create new one
            const newSession = this.generateSessionId();
            this.setSessionInURL(newSession);
        }
    }

    generateSessionId() {
        // Generate a unique session ID combining timestamp and random string
        const timestamp = new Date().getTime();
        const random = Math.random().toString(36).substring(2, 15);
        return `${timestamp}_${random}`;
    }

    getSessionFromURL() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(this.sessionParam);
    }

    setSessionInURL(sessionId) {
        // Get current URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        
        // Set session parameter
        urlParams.set(this.sessionParam, sessionId);
        
        // Update URL without reloading page
        const newUrl = `${window.location.pathname}?${urlParams.toString()}`;
        window.history.pushState({ path: newUrl }, '', newUrl);
    }

    async handleExistingSession(sessionId) {
        try {
            // Placeholder for future API call
            // const sessionData = await this.fetchSessionData(sessionId);
            
            // For now, just log that we'd restore the session
            console.log(`Would restore session: ${sessionId}`);
            
            // This is where we'll restore the state once API is implemented
            // this.restoreSessionState(sessionData);
        } catch (error) {
            console.error('Error handling existing session:', error);
        }
    }

    // Placeholder for future API call
    async fetchSessionData(sessionId) {
        // This will be implemented later
        // return await fetch(`/api/sessions/${sessionId}`);
    }

    // Method to restore state from session data
    restoreSessionState(sessionData) {
        // Example of how we'll restore state when we have the API
        if (sessionData.library) {
            this.stepManager.setLibrary(sessionData.library);
        }
        if (sessionData.method) {
            this.stepManager.setMethod(sessionData.method);
        }
    }

    // Method to get current state for saving
    getCurrentState() {
        return {
            sessionId: this.getSessionFromURL(),
            ...this.stepManager.getState()
        };
    }
}

class StepManager {
    constructor() {
        this.state = {
            library: null,
            method: null
        };
        this.api = APIConfig;
        this.sessionManager = new SessionManager(this);
    }

    init() {
        // Initialize session management first
        this.sessionManager.init();
        
        // Then initialize the rest
        this.setupLibraryListeners();
        this.setupMethodListeners();
        this.updateInactiveStates();
    }

    setupLibraryListeners() {
        document.querySelectorAll('[data-library-option]').forEach(element => {
            element.addEventListener('click', (e) => {
                if (!element.classList.contains('inactive')) {
                    const option = e.target.dataset.libraryOption;
                    this.setLibrary(option);
                }
            });
        });
    }

    setupMethodListeners() {
        document.querySelectorAll('[data-method-option]').forEach(element => {
            element.addEventListener('click', (e) => {
                if (!element.classList.contains('inactive')) {
                    const option = e.target.dataset.methodOption;
                    this.setMethod(option);
                }
            });
        });
    }

    setLibrary(library) {
        // Remove active class from all library options
        document.querySelectorAll('[data-library-option]').forEach(element => {
            element.classList.remove('active');
        });

        // Update state
        this.state.library = library;

        // Add active class to selected library
        if (library) {
            const element = document.querySelector(`[data-library-option="${library}"]`);
            if (element) {
                element.classList.add('active');
            }

            // Apply library-specific changes
            const config = StepConfig.library.options[library];
            if (config) {
                this.applyVisibilityRules(config.visibility);
                this.applyTextRules(config.text);
            }
        }

        // Update inactive states
        this.updateInactiveStates();

        // Check if current method is valid with new library
        if (this.state.method) {
            const libraryConfig = StepConfig.library.options[library];
            if (libraryConfig && libraryConfig.inactiveMethods.includes(this.state.method)) {
                this.setMethod(null);
            }
        }

        this.emitStateChange();
    }

    setMethod(method) {
        // Remove active class from all method options
        document.querySelectorAll('[data-method-option]').forEach(element => {
            element.classList.remove('active');
        });

        // Update state
        this.state.method = method;

        // Add active class to selected method
        if (method) {
            const element = document.querySelector(`[data-method-option="${method}"]`);
            if (element) {
                element.classList.add('active');
            }

            // Apply method-specific changes
            const config = StepConfig.method.options[method];
            if (config) {
                this.applyVisibilityRules(config.visibility);
                this.applyTextRules(config.text);
            }
        }

        // Update inactive states
        this.updateInactiveStates();

        this.emitStateChange();
    }

    updateInactiveStates() {
        // First, remove all inactive classes
        document.querySelectorAll('[data-library-option], [data-method-option]')
            .forEach(element => {
                element.classList.remove('inactive');
            });

        // Apply inactive states based on current library selection
        if (this.state.library) {
            const libraryConfig = StepConfig.library.options[this.state.library];
            if (libraryConfig && libraryConfig.inactiveMethods) {
                libraryConfig.inactiveMethods.forEach(methodName => {
                    const methodElement = document.querySelector(
                        `[data-method-option="${methodName}"]`
                    );
                    if (methodElement) {
                        methodElement.classList.add('inactive');
                    }
                });
            }
        }

        // Apply inactive states based on current method selection
        if (this.state.method) {
            const methodConfig = StepConfig.method.options[this.state.method];
            if (methodConfig && methodConfig.inactiveLibraries) {
                methodConfig.inactiveLibraries.forEach(libraryName => {
                    const libraryElement = document.querySelector(
                        `[data-library-option="${libraryName}"]`
                    );
                    if (libraryElement) {
                        libraryElement.classList.add('inactive');
                    }
                });
            }
        }
    }

    applyVisibilityRules(rules) {
        Object.entries(rules).forEach(([selector, shouldShow]) => {
            const elements = document.querySelectorAll(selector);
            elements.forEach(element => {
                element.classList.toggle('hidden', !shouldShow);
            });
        });
    }

    applyTextRules(rules) {
        Object.entries(rules).forEach(([selector, text]) => {
            const elements = document.querySelectorAll(selector);
            elements.forEach(element => {
                element.textContent = text;
            });
        });
    }

    emitStateChange() {
        document.dispatchEvent(new CustomEvent('step:stateChanged', {
            detail: {
                state: this.getState(),
                searchAPI: this.getSearchAPI()
            }
        }));
    }

    getState() {
        return { ...this.state };
    }

    getSearchAPI() {
        return this.api.getFullURL(this.state.library, 'search');
    }

    // Helper method to check current environment
    isStaging() {
        return this.api.getEnvironment() === 'staging';
    }
}

// Usage example:
const stepManager = new StepManager();
stepManager.init();

// Listen for state changes
document.addEventListener('step:stateChanged', (event) => {
    const { state, searchAPI } = event.detail;
    console.log('Current state:', state);
    console.log('Search API URL:', searchAPI);
    console.log('Is staging:', stepManager.isStaging());
});

// Example of making an API call
async function performSearch(searchParams) {
    const searchAPI = stepManager.getSearchAPI();
    if (!searchAPI) {
        throw new Error('Search API URL not available - library not selected');
    }

    try {
        const response = await fetch(searchAPI, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(searchParams)
        });

        return await response.json();
    } catch (error) {
        console.error('Search API error:', error);
        throw error;
    }
}
